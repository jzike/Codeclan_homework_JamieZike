---
title: "R Notebook"
output: html_notebook
---

# Libraries

```{r}
library(tidyverse)
library(janitor)
```
# MVP

## Q1 - Load the data, clean_names() and explore it.


```{r}
mobile_reviews <- read_csv("20190928-items.csv") %>% clean_names()
```

```{r}
mobile_reviews %>% names()

mobile_reviews %>% skimr::skim()

mobile_reviews
```


## Q2 - Find the brand with the highest numbers of phones in the dataset.

Samsung - 392 phones

```{r}
mobile_reviews %>% 
  group_by(brand) %>% 
  summarise(count = n_distinct(title))
```



## Q3 - For your top brand, plot the distribution of phone ratings as a probability density, overlaying a fitted normal distribution. Do you think the normal distribution provides a good model of these ratings?

No, it's not a very good fit. The relatively high probability bars in the "1"
and "5" ratings indicate that there is a fair portion of the data here, which 
seems to indicate that the data doesn't fit a normal distribution. In a normal 
distribution, there would be a relatively low probability of very high or very 
low ratings. The SD calculations below show that 99.7% of the data should lie
in the range of 1.60 and 5.6. This is clearly not the case since there is a
relatively high probability of a "1" rating. We can also see below that the 
Shapiro-Wilk test is violated here since the p value is statistically 
significant.

```{r}
mobile_reviews %>% 
  filter(brand == "Samsung") %>% 
  ggplot(aes(x = rating)) +
  geom_histogram(aes(y = ..density..)) +
  stat_function(
    fun = ~dnorm(.,mean = mean(mobile_reviews$rating),
                    sd = sd(mobile_reviews$rating))
  )
#99.7% of the ratings should fall within 3 standard deviations of the mean.
sd(mobile_reviews$rating)*3 + mean(mobile_reviews$rating)
mean(mobile_reviews$rating) - sd(mobile_reviews$rating)*3
```

```{r}
samsung_data <- mobile_reviews %>% 
  filter(brand == "Samsung")

options(scipen = 99)  
shapiro.test(samsung_data$rating)
```

## Q4 - We can be more quantitative in comparing the distribution of top brand ratings with a normal distribution. You calculated the mean() and sd() of your distribution in an earlier question. Use these values to calculate the proportions of ratings within one-, two- and three standard deviations of the mean. Compare these proportions with those you expect for a normal distribution.

Within one SD of mean: 2.939 - 4.276
Within two SD of mean: 2.270 - 4.945
Within three SD of mean: 1.601 - 5.614

Within One SD: 0.7657431	
Within Two SD: 0.9193955	
Within Three SD: 0.9798489	
With outliers:	1.0000000	

Compared with the normal distribution:
One SD - 68% - the samsung dataset has more
Two SD - 95% - The samsung dataset has less within Two SDs
Three SD - 99.7% - The samsung dataset has less within Two SDs.

Confirms that this data doesn't fit a normal distribution.

```{r}
sd(mobile_reviews$rating)*1 + mean(mobile_reviews$rating)
mean(mobile_reviews$rating) - sd(mobile_reviews$rating)*1

sd(mobile_reviews$rating)*2 + mean(mobile_reviews$rating)
mean(mobile_reviews$rating) - sd(mobile_reviews$rating)*2

sd(mobile_reviews$rating)*3 + mean(mobile_reviews$rating)
mean(mobile_reviews$rating) - sd(mobile_reviews$rating)*3


samsung_data <- samsung_data %>% 
  #add a column that shows whether a value lies within 1, 2 or 3 SDs of the mean
 mutate(num_sd =  case_when(
    between(rating, 2.939, 4.276) ~
            "One SD",
    between(rating,
            2.270, 4.945) ~
            "Two SD",
    between(rating,
            1.601, 5.614) ~
            "Three SD",
#keep any NAs because I can't remember if there were any
    is.na(rating) ~ NA_character_,
#assign all remaining values as outliers.
    TRUE ~ "Outlier"
  ), .after = rating)

samsung_data %>% 
  #group by the number of SDs
  group_by(num_sd) %>% 
  #summarise the number of ratings in each category
  summarise(count = n()) %>% 
  #get the probability for each category of ratings
  mutate(prob = count / sum(count)) %>% 
  #arrange in the correct order (to prep for cumsum)
  arrange(factor(num_sd, levels = c(
    "One SD",
    "Two SD",
    "Three SD",
    "Outlier"
  ))) %>% 
  #get the cumulative sum of prob in a new column
  mutate(csum = cumsum(prob))

```

